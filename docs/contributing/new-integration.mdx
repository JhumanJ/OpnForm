---
title: "Adding a New OAuth Integration"
description: "Complete guide to implementing OAuth integrations in OpnForm with architecture overview, flow diagrams, and step-by-step implementation"
---

This guide covers how to add new OAuth integrations to OpnForm. The system uses a modern, service-oriented architecture with strategy patterns to handle different OAuth flows including authentication, integrations, and widget-based providers.

## System Architecture Overview

OpnForm's OAuth system is built around several key architectural patterns:

- **Strategy Pattern**: Different completion strategies for auth vs integration flows
- **Driver Pattern**: Abstracted OAuth provider implementations 
- **Service Layer**: Centralized connection handling and flow coordination
- **Message-based Communication**: Cross-window communication for OAuth callbacks

```mermaid
graph TB
    subgraph "Frontend (Nuxt/Vue)"
        UI[User Interface]
        useOAuth[useOAuth Composable]
        useWindowMessage[useWindowMessage Composable]
        useAuthFlow[useAuthFlow Composable]
        TanStackQuery[TanStack Query Cache]
    end
    
    subgraph "Backend API (Laravel)"
        OAuthController[OAuthController]
        OAuthConnectionService[OAuthConnectionService]
        
        subgraph "Completion Strategies"
            AuthStrategy[AuthenticationStrategy]
            IntegrationStrategy[IntegrationStrategy] 
            WidgetStrategy[WidgetStrategy]
        end
        
        subgraph "OAuth Drivers"
            GoogleDriver[OAuthGoogleDriver]
            StripeDriver[OAuthStripeDriver]
            TelegramDriver[OAuthTelegramDriver]
            NewDriver[OAuthNewProviderDriver]
        end
        
        subgraph "Data Layer"
            UserModel[User Model]
            OAuthProviderModel[OAuthProvider Model]
            Cache[Laravel Cache]
        end
    end
    
    subgraph "External Services"
        GoogleOAuth[Google OAuth]
        StripeOAuth[Stripe Connect]
        TelegramWidget[Telegram Widget]
        NewProviderOAuth[New Provider OAuth]
    end
    
    %% Frontend to Backend API calls
    UI --> useOAuth
    useOAuth --> OAuthController
    useAuthFlow --> OAuthController
    
    %% OAuth Controller orchestration
    OAuthController --> OAuthConnectionService
    OAuthController --> Cache
    
    %% Service to Strategies
    OAuthConnectionService --> AuthStrategy
    OAuthConnectionService --> IntegrationStrategy
    OAuthConnectionService --> WidgetStrategy
    
    %% Strategies to Drivers
    AuthStrategy --> GoogleDriver
    AuthStrategy --> StripeDriver
    AuthStrategy --> TelegramDriver
    IntegrationStrategy --> GoogleDriver
    IntegrationStrategy --> StripeDriver
    WidgetStrategy --> TelegramDriver
    
    %% Drivers to External Services
    GoogleDriver --> GoogleOAuth
    StripeDriver --> StripeOAuth
    TelegramDriver --> TelegramWidget
    NewDriver --> NewProviderOAuth
    
    %% Data persistence
    AuthStrategy --> UserModel
    AuthStrategy --> OAuthProviderModel
    IntegrationStrategy --> OAuthProviderModel
    WidgetStrategy --> OAuthProviderModel
    
    %% Cross-window communication
    useWindowMessage -.->|"OAuth Callbacks"| useOAuth
    useWindowMessage -.->|"Cache Invalidation"| TanStackQuery
    
    %% Cache invalidation
    TanStackQuery -.->|"Refetch on Changes"| useOAuth
    
    classDef frontend fill:#e1f5fe
    classDef backend fill:#f3e5f5
    classDef external fill:#fff3e0
    classDef data fill:#e8f5e8
    
    class UI,useOAuth,useWindowMessage,useAuthFlow,TanStackQuery frontend
    class OAuthController,OAuthConnectionService,AuthStrategy,IntegrationStrategy,WidgetStrategy,GoogleDriver,StripeDriver,TelegramDriver,NewDriver backend
    class GoogleOAuth,StripeOAuth,TelegramWidget,NewProviderOAuth external
    class UserModel,OAuthProviderModel,Cache data
```

## Core Components

### 1. OAuthController (`api/app/Http/Controllers/Auth/OAuthController.php`)

The main controller that orchestrates OAuth flows:

```php
class OAuthController extends Controller
{
    public function __construct(private OAuthConnectionService $oauthService) {}

    // Initiates OAuth flow with intent-based scoping
    public function redirect(Request $request, string $provider)
    
    // Handles standard OAuth callbacks
    public function callback(string $provider)
    
    // Handles widget-based OAuth (e.g., Telegram)
    public function handleWidgetCallback(string $service, Request $request)
}
```

**Key Features:**
- **Intent-based scoping**: Different OAuth scopes for `auth` vs `integration` flows
- **Context caching**: Stores integration context for callback handling
- **Strategy selection**: Automatically chooses completion strategy based on authentication state

### 2. OAuthConnectionService (`api/app/Integrations/OAuth/OAuthConnectionService.php`)

Central service that handles OAuth connection logic:

```php
class OAuthConnectionService
{
    // Generates OAuth redirect URLs with custom scopes
    public function getRedirectUrl(OAuthProviderService $provider, array $scopes = []): string
    
    // Processes OAuth callbacks using completion strategies  
    public function handleCallback(OAuthProviderService $provider, OAuthCompletionStrategy $strategy): JsonResponse
}
```

### 3. Completion Strategies

The system uses three completion strategies that implement `OAuthCompletionStrategy`:

#### AuthenticationStrategy 
For user login/registration when user is not authenticated:

```php
class AuthenticationStrategy extends BaseOAuthCompletionStrategy
{
    public function execute(OAuthProviderService $provider, SocialiteUser $socialiteUser): JsonResponse
    {
        // Handle user creation/login, workspace assignment, JWT generation
    }
}
```

#### IntegrationStrategy
For connecting OAuth accounts when user is already logged in:

```php  
class IntegrationStrategy extends BaseOAuthCompletionStrategy
{
    public function execute(OAuthProviderService $provider, SocialiteUser $socialiteUser): JsonResponse
    {
        // Create/update OAuthProvider record, return connection details
    }
}
```

#### WidgetStrategy
For widget-based authentication (like Telegram Login Widget):

```php
class WidgetStrategy extends BaseOAuthCompletionStrategy
{
    public function handleWidgetCallback(OAuthProviderService $service, Request $request): JsonResponse
    {
        // Verify widget data, extract user info, create provider record
    }
}
```

### 4. OAuth Drivers

Each provider implements the `OAuthDriver` interface:

```php
interface OAuthDriver
{
    public function getRedirectUrl(): string;
    public function getUser(): User;
    public function canCreateUser(): bool;
    public function getScopesForIntent(string $intent): array;
}
```

For widget-based providers, implement `WidgetOAuthDriver`:

```php
interface WidgetOAuthDriver extends OAuthDriver
{
    public function verifyWidgetData(array $data): bool;
    public function getUserFromWidgetData(array $data): array;
    public function isWidgetBased(): bool;
}
```

## OAuth Flow Types

### Authentication Flow (User Login/Registration)

```mermaid
flowchart TD
    A["User clicks 'Sign in with Provider'"] --> B["Frontend: useOAuth.guestConnect()"]
    B --> C["API: POST /oauth/connect/provider?intent=auth"]
    C --> D{Provider can create users?}
    D -->|No| E["Return 422 Error"]
    D -->|Yes| F["Get auth scopes for provider"]
    F --> G["Generate OAuth redirect URL"]
    G --> H["Open OAuth provider window"]
    H --> I["User authorizes at provider"]
    I --> J["Provider redirects to callback"]
    J --> K["API: POST /oauth/provider/callback"]
    K --> L{User authenticated?}
    L -->|No| M["Use AuthenticationStrategy"]
    L -->|Yes| N["Use IntegrationStrategy"]
    M --> O["Find or create user"]
    O --> P["Create workspace if new user"]
    P --> Q["Generate JWT token"]
    Q --> R["Return token response"]
    R --> S["Frontend: Store token"]
    S --> T["Send LOGIN_COMPLETE message"]
    T --> U["Close OAuth window"]
    U --> V["Redirect to dashboard"]
    
    E --> W["Show error message"]
    
    subgraph "Window Communication"
        X["OAuth Callback Window"] --> Y["useWindowMessage.send()"]
        Y --> Z["Parent Window Listener"]
        Z --> AA["Cache invalidation"]
        AA --> BB["UI updates"]
    end
    
    classDef process fill:#e3f2fd
    classDef decision fill:#fff3e0
    classDef error fill:#ffebee
    classDef communication fill:#f3e5f5
    
    class A,B,C,F,G,H,I,J,K,O,P,Q,R,S,T,U,V process
    class D,L decision
    class E,W error
    class X,Y,Z,AA,BB communication
```

```mermaid
sequenceDiagram
    participant U as User
    participant F as Frontend
    participant API as OAuthController
    participant P as OAuth Provider
    participant AS as AuthenticationStrategy
    
    U->>F: Click "Sign in with Provider"
    F->>API: POST /oauth/connect/{provider}?intent=auth
    API->>P: Redirect to provider OAuth
    P->>U: User authorizes app
    P->>API: Callback with authorization code
    API->>AS: Execute authentication strategy
    AS->>AS: Create/find user, generate JWT
    AS->>F: Return JWT token
    F->>F: Store token, redirect to dashboard
```

**Key Steps:**
1. Frontend calls `/oauth/connect/{provider}` with `intent=auth`
2. Controller validates provider can create users
3. User redirected to OAuth provider with basic scopes
4. Provider callbacks to `/oauth/{provider}/callback`
5. `AuthenticationStrategy` handles user creation/login
6. JWT token returned for client-side authentication

### Integration Flow (Connect Account)

```mermaid
sequenceDiagram
    participant U as Logged User
    participant F as Frontend
    participant API as OAuthController
    participant P as OAuth Provider
    participant IS as IntegrationStrategy
    participant C as Cache
    
    U->>F: Click "Connect Account" 
    F->>API: POST /oauth/connect/{provider}?intent=integration
    API->>C: Store integration context
    API->>P: Redirect with full permission scopes
    P->>U: User authorizes extended permissions
    P->>API: Callback with authorization code
    API->>IS: Execute integration strategy
    IS->>IS: Create/update OAuthProvider record
    IS->>C: Retrieve integration context
    IS->>F: Return provider details + context
    F->>F: Update UI, invalidate cache
```

**Key Features:**
- **Enhanced scopes**: Requests full permissions needed for integrations
- **Context preservation**: Stores `intention` and `autoClose` settings in cache
- **Provider management**: Creates/updates `OAuthProvider` records

### Widget Flow (e.g., Telegram)

```mermaid
sequenceDiagram
    participant U as User
    participant W as Widget
    participant F as Frontend  
    participant API as OAuthController
    participant WS as WidgetStrategy
    
    U->>W: Authenticate with provider widget
    W->>F: Widget callback with auth data
    F->>API: POST /oauth/widget-callback/{provider}
    API->>WS: Execute widget strategy
    WS->>WS: Verify widget data signature
    WS->>WS: Extract user data
    WS->>WS: Create OAuthProvider record
    WS->>F: Return provider details
    F->>F: Update UI, show success
```

**Widget Authentication Features:**
- **No redirect flow**: Authentication happens in-place via widget
- **Data verification**: Cryptographic verification of widget data
- **Direct provider creation**: Immediately creates provider records

## Frontend Integration

### Window Message Communication

The frontend uses `useWindowMessage` composable for cross-window communication:

```javascript
// WindowMessageTypes for consistent messaging
export const WindowMessageTypes = {
  LOGIN_COMPLETE: 'login-complete',
  AFTER_LOGIN: 'after-login', 
  OAUTH_PROVIDER_CONNECTED: 'oauth-provider-connected'
}

// Usage in OAuth callback
const { send } = useWindowMessage(WindowMessageTypes.LOGIN_COMPLETE)
send(window.opener, {
  eventType: WindowMessageTypes.LOGIN_COMPLETE,
  useMessageChannel: false,
  waitForAcknowledgment: false
})
```

### OAuth Composable (`useOAuth`)

Centralized OAuth operations with TanStack Query integration:

```javascript
const { connect, connectMutation, services } = useOAuth()

// Connect to OAuth provider
await connect('google', false, true, true) // service, redirect, newtab, autoClose

// Service definitions with auth types
const services = [
  {
    name: 'google',
    title: 'Google', 
    auth_type: 'redirect' // Standard OAuth redirect flow
  },
  {
    name: 'telegram',
    title: 'Telegram',
    auth_type: 'widget', // Widget-based authentication
    widget_file: 'TelegramWidget'
  }
]
```

### Cache Management

The system automatically invalidates TanStack Query cache when OAuth connections change:

```javascript
// Listen for OAuth provider connections
windowMessage.listen((_event) => {
  invalidateProviders() // Refresh OAuth providers list
}, {
  useMessageChannel: false,
  acknowledge: false
})
```

## Adding a New Integration

Follow these steps to add a new OAuth provider to OpnForm:

<Steps>
<Step title="Create OAuth Driver">
Implement the OAuth driver class:

```php
// api/app/Integrations/OAuth/Drivers/OAuthNewProviderDriver.php
<?php

namespace App\Integrations\OAuth\Drivers;

use App\Integrations\OAuth\Drivers\Contracts\OAuthDriver;
use Laravel\Socialite\Contracts\User;
use Laravel\Socialite\Facades\Socialite;

class OAuthNewProviderDriver implements OAuthDriver
{
    private ?string $redirectUrl = null;
    private ?array $scopes = [];
    protected $provider;

    public function __construct()
    {
        $this->provider = Socialite::driver('newprovider');
    }

    public function getRedirectUrl(): string
    {
        return $this->provider
            ->scopes($this->scopes ?? [])
            ->stateless()
            ->redirectUrl($this->redirectUrl ?? config('services.newprovider.redirect'))
            ->redirect()
            ->getTargetUrl();
    }

    public function getUser(): User
    {
        return $this->provider
            ->stateless()
            ->redirectUrl($this->redirectUrl ?? config('services.newprovider.redirect'))
            ->user();
    }

    public function canCreateUser(): bool
    {
        return true; // Set false if provider can't be used for user registration
    }

    public function setRedirectUrl(string $url): OAuthDriver
    {
        $this->redirectUrl = $url;
        return $this;
    }

    public function setScopes(array $scopes): OAuthDriver
    {
        $this->scopes = $scopes;
        return $this;
    }

    public function getScopesForIntent(string $intent): array
    {
        return match ($intent) {
            'auth' => ['user:email', 'read:user'],
            'integration' => ['user:email', 'read:user', 'write:data'],
            default => ['user:email', 'read:user'],
        };
    }
}
```

<Tip>
Configure different scopes for `auth` vs `integration` intents. Auth scopes should be minimal (just enough for user identification), while integration scopes should include all permissions needed for the provider's functionality.
</Tip>
</Step>

<Step title="Register in Provider Service">
Add your new provider to the enum:

```php
// api/app/Integrations/OAuth/OAuthProviderService.php
enum OAuthProviderService: string
{
    case Google = 'google';
    case Stripe = 'stripe';
    case Telegram = 'telegram';
    case NewProvider = 'newprovider'; // Add your provider

    public function getDriver(): OAuthDriver
    {
        return match ($this) {
            self::Google => new OAuthGoogleDriver(),
            self::Stripe => new OAuthStripeDriver(), 
            self::Telegram => new OAuthTelegramDriver(),
            self::NewProvider => new OAuthNewProviderDriver(), // Add mapping
        };
    }
}
```
</Step>

<Step title="Configure Services">
Add configuration to `api/config/services.php`:

```php
// api/config/services.php
'newprovider' => [
    'client_id' => env('NEWPROVIDER_CLIENT_ID'),
    'client_secret' => env('NEWPROVIDER_CLIENT_SECRET'),
    'redirect' => env('APP_URL') . '/oauth/newprovider/callback',
],
```

Add environment variables to `.env.example`:

```bash
# New Provider OAuth
NEWPROVIDER_CLIENT_ID=
NEWPROVIDER_CLIENT_SECRET=
```
</Step>

<Step title="Install Socialite Provider">
If using a community Socialite provider, add it to `composer.json`:

```bash
cd api && composer require socialiteproviders/newprovider
```

Register in `api/app/Providers/EventServiceProvider.php`:

```php
protected $listen = [
    \SocialiteProviders\Manager\SocialiteWasCalled::class => [
        'SocialiteProviders\\NewProvider\\NewProviderExtendSocialite@handle',
    ],
];
```
</Step>

<Step title="Add Frontend Service Definition">
Update the frontend service configuration:

```javascript
// client/composables/query/useOAuth.js
const services = computed(() => {
  return [
    // ... existing services
    {
      name: 'newprovider',
      title: 'New Provider',
      icon: 'mdi:newprovider', // Use appropriate icon
      enabled: useFeatureFlag('services.newprovider.client_id', false),
      auth_type: 'redirect'
    }
  ]
})
```
</Step>

<Step title="Add Feature Flag">
Update feature flags controller to expose the provider:

```php
// api/app/Http/Controllers/Content/FeatureFlagsController.php
public function index(): JsonResponse
{
    return response()->json([
        // ... existing flags
        'services' => [
            // ... existing services
            'newprovider' => [
                'client_id' => !!config('services.newprovider.client_id'),
            ],
        ],
    ]);
}
```
</Step>

<Step title="Test the Integration">
Test both authentication and integration flows:

**Authentication Test:**
1. Start fresh (logged out)
2. Click "Sign in with New Provider"
3. Complete OAuth flow
4. Verify user creation and login

**Integration Test:**
1. Log in with existing account
2. Go to Settings → Connections
3. Click "Connect New Provider"
4. Complete OAuth flow
5. Verify provider appears in connected accounts

<Check>
Verify both flows work correctly and check that appropriate scopes are requested for each intent.
</Check>
</Step>

<Step title="Add Integration Handler (Optional)">
If your provider will be used for form integrations, create an integration handler:

```php
// api/app/Integrations/Handlers/NewProviderIntegration.php
<?php

namespace App\Integrations\Handlers;

use App\Integrations\Handlers\AbstractIntegrationHandler;

class NewProviderIntegration extends AbstractIntegrationHandler
{
    public static function getValidationRules(): array
    {
        return [
            'oauth_id' => 'required|exists:oauth_providers,id',
            'settings' => 'required|array'
        ];
    }

    public function handle(array $data): bool
    {
        // Implement integration logic here
        // e.g., send data to external API, create records, etc.
        
        return true;
    }
}
```

Register the handler and add frontend integration components as needed.
</Step>
</Steps>

## Widget-Based Providers

For providers that use widget authentication (like Telegram), implement `WidgetOAuthDriver`:

<Tabs>
<Tab title="Driver Implementation">
```php
<?php

namespace App\Integrations\OAuth\Drivers;

use App\Integrations\OAuth\Drivers\Contracts\WidgetOAuthDriver;

class OAuthWidgetProviderDriver implements WidgetOAuthDriver
{
    public function verifyWidgetData(array $data): bool
    {
        // Implement cryptographic verification of widget data
        // e.g., HMAC signature verification
        
        $expectedHash = hash_hmac('sha256', $dataString, $secretKey);
        return hash_equals($expectedHash, $data['hash']);
    }

    public function getUserFromWidgetData(array $data): array
    {
        return [
            'id' => $data['user_id'],
            'name' => $data['name'],
            'email' => $data['email'] ?? null,
            'provider_user_id' => $data['user_id'],
            'provider' => 'widgetprovider',
            'access_token' => $data['auth_token'],
            'scopes' => []
        ];
    }

    public function isWidgetBased(): bool
    {
        return true;
    }

    // Standard OAuthDriver methods...
    public function getRedirectUrl(): string
    {
        return ''; // Not used for widget auth
    }
}
```
</Tab>

<Tab title="Frontend Widget Component">
```vue
<!-- client/components/settings/widgets/WidgetProviderWidget.vue -->
<template>
  <div class="widget-provider-container">
    <div 
      id="widget-provider-login"
      @click="initializeWidget"
    >
      Connect Widget Provider
    </div>
  </div>
</template>

<script setup>
const emit = defineEmits(['auth-data'])

const initializeWidget = () => {
  // Initialize provider widget
  // Handle widget callback and emit auth data
  
  window.WidgetProvider.init({
    onAuth: (authData) => {
      emit('auth-data', authData)
    }
  })
}
</script>
```
</Tab>

<Tab title="Frontend Service Config">
```javascript
// Update service definition for widget providers
{
  name: 'widgetprovider',
  title: 'Widget Provider',
  icon: 'mdi:widget',
  enabled: useFeatureFlag('services.widgetprovider.enabled', false),
  auth_type: 'widget',
  widget_file: 'WidgetProviderWidget'
}
```
</Tab>
</Tabs>

## Advanced Configuration

### Custom Scopes and Parameters

OAuth drivers can customize the authorization request:

```php
public function getRedirectUrl(): string
{
    return $this->provider
        ->scopes($this->scopes)
        ->stateless()
        ->redirectUrl($this->redirectUrl)
        ->with([
            'access_type' => 'offline',
            'prompt' => 'consent',
            'custom_param' => 'value'
        ])
        ->redirect()
        ->getTargetUrl();
}
```

### Error Handling

The system includes comprehensive error handling:

```php
// In OAuthConnectionService
public function handleCallback(OAuthProviderService $provider, OAuthCompletionStrategy $strategy): JsonResponse
{
    try {
        $driverUser = $provider->getDriver()->getUser();
        return $strategy->execute($provider, $driverUser);
    } catch (\Exception $e) {
        report($e);
        return response()->json(['message' => 'Failed to authenticate with the provider. Please try again.'], 400);
    }
}
```

### Intent-Based Flow Control

The controller automatically selects the appropriate completion strategy:

```php
public function callback(string $provider)
{
    $providerService = OAuthProviderService::from($provider);

    // Strategy is determined by the user's authentication state
    $strategy = Auth::check()
        ? app(IntegrationStrategy::class)  // User logged in = integration
        : app(AuthenticationStrategy::class); // User not logged in = authentication

    return $this->oauthService->handleCallback($providerService, $strategy);
}
```

## Troubleshooting

<AccordionGroup>
<Accordion title="Provider not appearing in frontend">
- Check feature flag configuration in `FeatureFlagsController`
- Verify environment variables are set
- Ensure service is added to `useOAuth` services list
- Check browser console for JavaScript errors
</Accordion>

<Accordion title="OAuth redirect URL mismatch">
- Verify `redirect` URL in `config/services.php` matches provider configuration
- Check that `APP_URL` environment variable is correct
- Ensure provider OAuth app is configured with correct callback URL
</Accordion>

<Accordion title="Scopes not working correctly">
- Check `getScopesForIntent()` method returns correct scopes
- Verify provider OAuth app has necessary permissions enabled
- Test with minimal scopes first, then add additional ones
</Accordion>

<Accordion title="Widget authentication failing">
- Verify widget data signature verification logic
- Check that widget script is loaded correctly
- Ensure widget callback URL is accessible and correct
- Test widget data extraction and user creation flow
</Accordion>
</AccordionGroup>

## Best Practices

<Card title="Security" icon="shield-check">
- Always verify widget data signatures cryptographically
- Use minimal scopes for authentication flows
- Validate all OAuth provider responses
- Implement proper error handling and logging
</Card>

<Card title="User Experience" icon="heart">
- Provide clear loading states during OAuth flows
- Handle popup blockers gracefully
- Show appropriate error messages for OAuth failures
- Auto-close OAuth windows when appropriate
</Card>

<Card title="Performance" icon="bolt">
- Cache OAuth provider configurations
- Use TanStack Query for efficient data fetching
- Implement proper cleanup for event listeners
- Minimize API calls during OAuth flows
</Card>

This comprehensive architecture allows OpnForm to support any OAuth provider with a consistent, maintainable codebase that handles all the complexities of modern OAuth flows.