---
title: "Data Fetching"
description: "How we fetch and mutate server data in the front-end with TanStack Query."
---

<Info>
Authentication tokens are stored in **cookies** after login. `client/composables/useOpnApi.js` automatically injects the
`Authorization: Bearer <token>` header on every request, and the global middleware
`client/middleware/01.check-auth.global.js` pre-loads the current user & workspaces during navigation.<br/>
If you need to generate new tokens (e.g. for external scripts) see the [Authentication](../api-reference/introduction#authentication) docs.
</Info>

## Why TanStack Query?
We use [TanStack Query](https://tanstack.com/query/latest) to handle **server state**—data that lives in the database and is accessed through our API. It gives us:

- Automatic caching & background refetching
- Declarative loading / error states
- Built-in mutations with optimistic updates
- DevTools for debugging

For purely **client-side UI state** (theme, modals, etc.) we still rely on [Pinia](https://pinia.vuejs.org/) – see `client/stores/app.js` for an example.

## Reading data
```vue
<script setup>
// 1️⃣ Grab the query factory from the composable
const { list } = useWorkspaces()

// 2️⃣ Call it to register the query
const {
  data: workspaces,
  isLoading,
  isError,
  error
} = list()
</script>

<template>
  <div v-if="isLoading">Loading…</div>
  <div v-else-if="isError">{{ error.message }}</div>
  <ul v-else>
    <li v-for="ws in workspaces" :key="ws.id">{{ ws.name }}</li>
  </ul>
</template>
```

A query composable always returns a function (e.g. `list`) that you **call** to register the query. The options object you pass is forwarded directly to TanStack Query in case you need `staleTime`, `enabled`, etc.

## Mutating data
`mutateAsync` returns a Promise, so we recommend chaining handlers with `.then().catch()` to keep control flow explicit:

```vue
<script setup>
const { create } = useWorkspaces()
const createWorkspace = create() // register the mutation

const onSubmit = (form) => {
  createWorkspace
    .mutateAsync(form)
    .then(() => useAlert().success('Workspace created!'))
    .catch((err) => useAlert().error(err.message))
}
</script>
```

### Optimistic updates & cache layer
All mutations live in their composable (`client/composables/query/*`). After a successful API call they update the cache **manually** using `queryClient.setQueryData` so the UI reflects changes instantly *without* needing an extra network round-trip.

If you need to invalidate and refetch, every composable exposes `invalidate()` which calls `queryClient.invalidateQueries` for its namespace:

```js
import { useWorkspaces } from '@/composables/query'

useWorkspaces().invalidate() // refetch every workspace query
```

## Anatomy of a composable (quick tour)
Take `useWorkspaces.js` as an example:

1. **Queries** – `list()`, `detail(id)`
2. **Mutations** – `create()`, `update()`, `remove()`
3. **Utilities** – `invalidate()`

Each query/mutation is a thin wrapper around `workspaceApi.*`, keeps its own `queryKey`, and touches only the part of the cache it owns. This isolation makes cache behaviour predictable and prevents accidental over-fetching.

### Waiting for completion with `suspense()`
Every query instance exposes a `suspense()` method that returns a Promise resolving once the data is loaded. Our auth middleware uses it to block navigation until the user and workspace lists are ready:

```js
// client/middleware/01.check-auth.global.js (excerpt)
const userQuery = useAuth().user()
const workspacesQuery = useWorkspaces().list()

await Promise.all([
  userQuery.suspense(),
  workspacesQuery.suspense(),
])
```

## Loading & error states
Every query exposes booleans such as `isLoading`, `isFetching`, `isError`. Mutations expose `isPending`. Use them to drive spinners, disabled states, or retry logic.

<Tip>
`isFetching && data` is perfect for subtle "background update" indicators.
</Tip>

## TL;DR
- Use **TanStack Query composables** for anything that comes from the API.
- Use **Pinia** only for UI or session state.
- Mutate with `mutateAsync().then().catch()`.
- Call `invalidate()` when you really need a refetch—otherwise rely on optimistic updates. 